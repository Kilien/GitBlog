[{"categories":["Algorithm"],"content":"LeetCode-160相交链表 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表**：** 相交链表\" 相交链表 在节点 c1 开始相交。 示例： 示例\" 示例 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 ","date":"2020-11-10","objectID":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-160-相交链表","uri":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"},{"categories":["Algorithm"],"content":"思路 指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历 如果 pA 到了末尾，则 pA = headB 继续遍历 如果 pB 到了末尾，则 pB = headA 继续遍历 如果较长的链表指针指向较短链表head时，长度差就消除了 只需要将最短链表遍历两次即可找到位置 A = a + c(公共部分) B = b +c(公共部分) 将 A B 相连 pA = A + B = (a + c + b) + c pB = B + A = (b + c + a) + c 如果 A B 有交点, 刚好在 c 开始时相遇 ","date":"2020-11-10","objectID":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/:1:0","tags":["算法","Leetcode"],"title":"LeetCode-160-相交链表","uri":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"},{"categories":["Algorithm"],"content":"代码 class Solution(object): def getIntersectionNode(self, headA, headB): “”” :type head1, head1: ListNode :rtype: ListNode “”” if not headA or not headB: return None pa = headA pb = headB while pa is not pb: pa = headB if pa is None else pa.next pb = headA if pb is None else pb.next return pa ","date":"2020-11-10","objectID":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/:2:0","tags":["算法","Leetcode"],"title":"LeetCode-160-相交链表","uri":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"},{"categories":["Algorithm"],"content":"复杂度 ","date":"2020-11-10","objectID":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/:3:0","tags":["算法","Leetcode"],"title":"LeetCode-160-相交链表","uri":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"},{"categories":["Algorithm"],"content":"时间：O(n) ","date":"2020-11-10","objectID":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/:3:1","tags":["算法","Leetcode"],"title":"LeetCode-160-相交链表","uri":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"},{"categories":["Algorithm"],"content":"空间：O(1) ","date":"2020-11-10","objectID":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/:3:2","tags":["算法","Leetcode"],"title":"LeetCode-160-相交链表","uri":"/LeetCode-160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"},{"categories":["Algorithm"],"content":"LeetCode-821-字符的最短距离 ","date":"2020-11-02","objectID":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/:0:0","tags":["算法"],"title":"LeetCode-821-字符的最短距离","uri":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/"},{"categories":["Algorithm"],"content":"题目 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。 示例 1: 输入: S = “loveleetcode”, C = ‘e’ 输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] 说明: 字符串 S 的长度范围为 [1, 10000]。 C 是一个单字符，且保证是字符串 S 里的字符。 S 和 C 中的所有字母均为小写字母。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2020-11-02","objectID":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/:1:0","tags":["算法"],"title":"LeetCode-821-字符的最短距离","uri":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/"},{"categories":["Algorithm"],"content":"思路 遍历数组，找到等于 C 的字符下标，设置位移坐标pos 遍历数组下标： 依次与 pos 相减取绝对值，再从中选取最小值添加到 ans ","date":"2020-11-02","objectID":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/:2:0","tags":["算法"],"title":"LeetCode-821-字符的最短距离","uri":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/"},{"categories":["Algorithm"],"content":"代码 class Solution: def shortestToChar(self, S: str, C: str) -\u003e List[int]: pos = [] for i, v in enumerate(S): if v == C: pos.append(i) #output：【3，5，6，11】 ans = [] for i in range(len(S)): ans.append(min(abs(t - i) for t in pos)) return ans #[3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0, 3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] ","date":"2020-11-02","objectID":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/:3:0","tags":["算法"],"title":"LeetCode-821-字符的最短距离","uri":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/"},{"categories":["Algorithm"],"content":"复杂度 时间：O(nm) 空间：O(n) ","date":"2020-11-02","objectID":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/:4:0","tags":["算法"],"title":"LeetCode-821-字符的最短距离","uri":"/LeetCode-821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/"},{"categories":["Algorithm"],"content":"LeetCode-66 加一 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:0:0","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"题目 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,9,9,9] 输出: [5,0,0,0] 解释: 输入数组表示数字 5000。 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:1:0","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"解法一 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:2:0","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"思路 将数组中的每一个字符连接成一个字符串； 然后字符串转换为整数，再将数字增加1； 分割数字，组成另一个数组 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:2:1","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"代码 class Solution: def plusOne(self, digits: List[int]) -\u003e List[int]: num = \"\" for i in digits: num += str(i) num = str(int(num) + 1) ans = [] for i in num: ans.append(int(i)) return ans ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:2:2","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"复杂度 空间：O(n) 时间：O(n) ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:2:3","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"解法二 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:3:0","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"思路 和第一种思路类似 遍历数组，将数组变成数字形式 新数字加一 分割数字，组成另一个数组 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:3:1","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"代码 class Solution: def plusOne(self, digits: List[int]) -\u003e List[int]: intNum = 0 for i in range(len(digits)): intNum = intNum*10 + digits[i] intNum += 1 res = [] for i in str(intNum): res.append(int(i)) return res ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:3:2","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"复杂度 空间：O(n) 时间：O(n) ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:3:3","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"解法三 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:4:0","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"思路 换个思路，加一无非两个情况 末位为 9 需要进位 末位不为 9，直接加一 首先设边界条件，若无数字则为一 末位为 9： 截取除最后一位外的数组，末位加一 新数组结尾填零 末位不为 9： 末位直接加一 ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:4:1","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"代码 class Solution: def plusOne(self, digits: List[int]) -\u003e List[int]: if len(digits) == 0: digits = [1] elif digits[-1] == 9: digits = self.plusOne(digits[:-1]) digits.extend([0]) else: digits[-1] += 1 return digits 为了好理解些，解释下代码 digits = self.plusOne(digits[:-1]) 示例： digits = [9, 0, 9] # digits = [9, 0, 9] digits = self.plusOne([9, 0]) # this returns [9, 1] # digits = [9, 1] digits.extend([0]) # digits = [9, 1, 0] ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:4:2","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Algorithm"],"content":"复杂度 时间：O(n) 空间：O(1) ","date":"2020-11-01","objectID":"/LeetCode-66-%E5%8A%A0%E4%B8%80/:4:3","tags":["算法"],"title":"LeetCode-66-加一","uri":"/LeetCode-66-%E5%8A%A0%E4%B8%80/"},{"categories":["Python"],"content":"Python技巧 ","date":"2020-10-09","objectID":"/PythonTrick/:0:0","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"原地交换两数 a = 10 b = 20 a, b = b, a print(b, a) print(a, b) 输出: 10 20 20 10 ","date":"2020-10-09","objectID":"/PythonTrick/:0:1","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"链式比较 n = 10 print(6 \u003c n \u003c 20) print(11 \u003c n \u003c 20) 输出: True False ","date":"2020-10-09","objectID":"/PythonTrick/:0:2","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"三元组操作 [表达式为真的返回值] if [表达式] else [表达式为假的返回值] a = 10 b = 1 if a == 0 else 0 print(b) 输出: 0 ","date":"2020-10-09","objectID":"/PythonTrick/:0:3","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"列表推导 a = [1,4,5,6,2,8,3,7,9] b = [i for i in a if i \u003e 5] print(b) c = [(0,1), (2,3), (4,6)] d = [r[1] for r in c] print(d) 输出: [6, 8, 7, 9] [1, 3, 6] ","date":"2020-10-09","objectID":"/PythonTrick/:0:4","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"列表/元祖切片 a = [1,2,3,4,5,6] # (1,2,3,4,5,6) b = a[2:] c = a[1:2] # 半闭半开 print(b) print(c) 输出: [3, 4, 5, 6] [2] ","date":"2020-10-09","objectID":"/PythonTrick/:0:5","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"基础函数实现 ","date":"2020-10-09","objectID":"/PythonTrick/:1:0","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"函数参数 def test(a, b, *args, ** kwargs): print(a, b, args, kwargs) test(1,2) test(1,2,3,4,t=5) n = [4,5] m = {'x':6, 'y':7} test(1,2, *n, ** m) # 结构传递，等同test(1,2,3,4,x=6,y=7) 输出: 1 2 () {} 1 2 (3, 4) {'t': 5} 1 2 (4, 5) {'x': 6, 'y': 7} ","date":"2020-10-09","objectID":"/PythonTrick/:1:1","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"统计列表中元素次数 a = [1,2,3,3,2,4,5] print(a.count(2)) 输出: 2 方法1 from collections import Counter a = [1,2,3,3,2,4,5] b = Counter(a) print(b) 方法2 a = [1,2,3,3,2,4,5] c = { i: a.count(i) for i in set(a) } print(c) 输出: Counter({2: 2, 3: 2, 1: 1, 4: 1, 5: 1}) {1: 1, 2: 2, 3: 2, 4: 1, 5: 1} ","date":"2020-10-09","objectID":"/PythonTrick/:1:2","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"列表去重 a = [1,2,3,3,2,4,5] b = list(set(a)) print(a, b) 输出: [1, 2, 3, 3, 2, 4, 5] [1, 2, 3, 4, 5] ","date":"2020-10-09","objectID":"/PythonTrick/:1:3","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字典推导 a = [['name','Robin'], ['age',30]] b = { r[0]: r[1] for r in a } print(b) 输出: {‘name': 'Robin', 'age': 30} ","date":"2020-10-09","objectID":"/PythonTrick/:1:4","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字典生成 a = [['name','Robin'], ['age',30]] b = dict(a) print(b) 输出: {'name': 'Robin', 'age': 30} ","date":"2020-10-09","objectID":"/PythonTrick/:1:5","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字典转元组 a = {'name':'Robin', 'age':30} print(list(a.items())) 输出: [('name', 'Robin'), ('age', 30)] ","date":"2020-10-09","objectID":"/PythonTrick/:1:6","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"zip 运用 a = [1,2,3,4] b = ['a','b','c','d'] c = zip(a, b) print(list(c)) 输出: [(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')] ","date":"2020-10-09","objectID":"/PythonTrick/:1:7","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字符串函数 ","date":"2020-10-09","objectID":"/PythonTrick/:2:0","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字符串重复 a = 'a' b = a * 10 print(b) 输出: aaaaaaaaaa ","date":"2020-10-09","objectID":"/PythonTrick/:2:1","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字符串拼接 a = ['Hello', 'World', '!'] b = '~'.join(a) print(b) 输出: Hello~World~! ","date":"2020-10-09","objectID":"/PythonTrick/:2:2","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字符串包含 a = 'Hello World !' print('World' in a) print('abc' in a) 输出: True False ","date":"2020-10-09","objectID":"/PythonTrick/:2:3","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"字符串翻转 class Solution: def reverseWords(self, s: str) -\u003e str: # join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。 # strip() 方法用于移除字符串头尾指定的字符（默认为空格）或字符序列。 return \" \".join(s.strip().split()[::-1]) 输出： 输入：\"a good example\" 输出：\"example good a\" 解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 ","date":"2020-10-09","objectID":"/PythonTrick/:2:4","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"列表推导实现 ","date":"2020-10-09","objectID":"/PythonTrick/:3:0","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"map a = [{'name':'A', 'id':1}, {'name':'B', 'id':2}] b = map(lambda d:d['id'], a) print(list(b)) ","date":"2020-10-09","objectID":"/PythonTrick/:3:1","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"列表推导实现 c = [d['id'] for d in a] print(c) 输出: [1, 2] [1, 2] ","date":"2020-10-09","objectID":"/PythonTrick/:3:2","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"filter a = [1,4,5,6,2,8,3,7,9] b = filter(lambda i: i \u003e 5, a) print(list(b)) ","date":"2020-10-09","objectID":"/PythonTrick/:3:3","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"列表推导实现 c = [i for i in a if i \u003e 5] print(c) 输出: [6, 8, 7, 9] [6, 8, 7, 9] ","date":"2020-10-09","objectID":"/PythonTrick/:3:4","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"代码格式优化 ","date":"2020-10-09","objectID":"/PythonTrick/:4:0","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"获取索引和元素 丑代码 a = ['A', 'B', 'C'] n = 0 for i in a: print(n, i) n += 1 for i in range(len(a)): print(i, a[i]) 推荐代码 for n, i in enumerate(a): print(n, i) 输出: 0 A 1 B 2 C 0 A 1 B 2 C 0 A 1 B 2 C ","date":"2020-10-09","objectID":"/PythonTrick/:4:1","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["Python"],"content":"简化 if a = 1 if a == 1 or a == 2 or a == 3 or a == 8: pass # 不推荐做法 if a in [1,2,3,8,9]: pass # 推荐做法 丑代码 a = 1 if a == 1: b = 'A' elif a == 2: b = 'B' else: b = 'C' print(b) 简化代码 d = {1:'A', 2:'B'} b = d.get(a, 'C') print(b) 输出: A A #web ","date":"2020-10-09","objectID":"/PythonTrick/:4:2","tags":["Python","Trick"],"title":"Python技巧","uri":"/PythonTrick/"},{"categories":["笔记"],"content":"python 生成器和迭代器 PS：这篇博客是我上网课做的笔记，也是参考网课老师的博客，就是学习笔记而已，不喜勿喷！ 本节主要记录一下列表生成式，生成器和迭代器的知识点 ","date":"2020-06-25","objectID":"/GeneratorAndYield/:0:0","tags":["笔记","Generator","Yield"],"title":"生成器的运用","uri":"/GeneratorAndYield/"},{"categories":["笔记"],"content":"列表生成器 首先举个例子 现在有个需求，看列表 [0，1，2，3，4，5，6，7，8，9]，要求你把列表里面的每个值加1，你怎么实现呢？ 方法一（简单）： info = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] b = [] # for index,i in enumerate(info): # print(i+1) # b.append(i+1) # print(b) for index,i in enumerate(info): info[index] +=1 print(info) 方法二（一般）： info = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] a = map(lambda x:x+1,info) print(a) for i in a: print(i) 方法三（高级）： info = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] a = [i+1 for i in range(10)] print(a) ","date":"2020-06-25","objectID":"/GeneratorAndYield/:0:1","tags":["笔记","Generator","Yield"],"title":"生成器的运用","uri":"/GeneratorAndYield/"},{"categories":["笔记"],"content":"生成器 什么是生成器？ 通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的，而且创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间，在Python中，这种一边循环一边计算的机制，称为生成器：generator 生成器是一个特殊的程序，可以被用作控制循环的迭代行为，python中生成器是迭代器的一种，使用yield返回值函数，每次调用yield会暂停，而可以使用next()函数和send()函数恢复生成器。 生成器类似于返回值为数组的一个函数，这个函数可以接受参数，可以被调用，但是，不同于一般的函数会一次性返回包括了所有数值的数组，生成器一次只能产生一个值，这样消耗的内存数量将大大减小，而且允许调用函数可以很快的处理前几个返回值，因此生成器看起来像是一个函数，但是表现得却像是迭代器 python中的生成器 　要创建一个generator，有很多种方法，第一种方法很简单， 只有把一个列表生成式的[]中括号改为（）小括号，就创建一个generator 举例如下： #列表生成式 lis = [x*x for x in range(10)] print(lis) #生成器 generator_ex = (x*x for x in range(10)) print(generator_ex) 结果： [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] \u003cgenerator object \u003cgenexpr\u003e at 0x000002A4CBF9EBA0\u003e 那么创建list和generator_ex，的区别是什么呢？从表面看就是[ ]和（）,但是结果却不一样，一个打印出来是列表（因为是列表生成式），而第二个打印出来却是\u003cgenerator object at 0x000002A4CBF9EBA0\u003e，那么如何打印出来generator_ex的每一个元素呢？ 如果要一个个打印出来，可以通过next（）函数获得generator的下一个返回值： #生成器 generator_ex = (x*x for x in range(10)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) print(next(generator_ex)) 结果： 0 1 4 9 16 25 36 49 64 81 Traceback (most recent call last): File \"列表生成式.py\", line 42, in \u003cmodule\u003e print(next(generator_ex)) StopIteration 大家可以看到，generator保存的是算法，每次调用next(generaotr_ex)就计算出他的下一个元素的值，直到计算出最后一个元素，没有更多的元素时，抛出StopIteration的错误，而且上面这样不断调用是一个不好的习惯，正确的方法是使用for循环，因为generator也是可迭代对象： #生成器 generator_ex = (x*x for x in range(10)) for i in generator_ex: print(i) 结果： 0 1 4 9 16 25 36 49 64 81 所以我们创建一个generator后，基本上永远不会调用next()，而是通过for循环来迭代，并且不需要关心StopIteration的错误，generator非常强大，如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。 比如著名的斐波那契数列，除第一个和第二个数外，任何一个数都可以由前两个相加得到： 1，1，2，3，5，8，12，21，34….. 斐波那契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易： #fibonacci数列 def fib(max): n,a,b =0,0,1 while n \u003c max: a,b =b,a+b n = n+1 print(a) return 'done' a = fib(10) print(fib(10)) a,b = b ,a+b 其实相当于 t =a+b ,a =b ,b =t ，所以不必写显示写出临时变量t，就可以输出斐波那契数列的前N个数字。上面输出的结果如下： 1 1 2 3 5 8 13 21 34 55 1 1 2 3 5 8 13 21 34 55 done 　仔细观察，可以看出， fib 函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。 也就是说上面的函数也可以用generator来实现，上面我们发现，print(b)每次函数运行都要打印，占内存，所以为了不占内存，我们也可以使用生成器，这里叫yield。如下： def fib(max): n,a,b =0,0,1 while n \u003c max: yield b a,b =b,a+b n = n+1 return 'done' a = fib(10) print(fib(10)) 但是返回的不再是一个值，而是一个生成器，和上面的例子一样，大家可以看一下结果： \u003cgenerator object fib at 0x000001C03AC34FC0\u003e 那么这样就不占内存了，这里说一下generator和函数的执行流程，函数是顺序执行的，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次被next（）调用时候从上次的返回yield语句处急需执行，也就是用多少，取多少，不占内存。 def fib(max): n,a,b =0,0,1 while n \u003c max: yield b a,b =b,a+b n = n+1 return 'done' a = fib(10) print(fib(10)) print(a.__next__()) print(a.__next__()) print(a.__next__()) print(\"可以顺便干其他事情\") print(a.__next__()) print(a.__next__()) 结果： \u003cgenerator object fib at 0x0000023A21A34FC0\u003e 1 1 2 可以顺便干其他事情 3 5 　在上面fib的例子，我们在循环过程中不断调用 yield ，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。同样的，把函数改成generator后，我们基本上从来不会用 next() 来获取下一个返回值，而是直接使用 for 循环来迭代： def fib(max): n,a,b =0,0,1 while n \u003c max: yield b a,b =b,a+b n = n+1 return 'done' for i in fib(6): print(i) 结果： 1 1 2 3 5 8 但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果拿不到返回值，那么就会报错，所以为了不让报错，就要进行异常处理，拿到返回值，如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中： def fib(max): n,a,b =0,0,1 while n \u003c max: yield b a,b =b,a+b n = n+1 return 'done' g = fib(6) while True: try: x = next(g) print('generator: ',x) except StopIteration as e: print(\"生成器返回值：\",e.value) break 结果： generator: 1 generator: 1 generator: 2 generator: 3 generator: 5 generator: 8 生成器返回值： done 还可以通过yield实现在单线程的情况下实现并发运算的效果 import time def consumer(name): print(\"%s准备学习啦!\" %name) while True: lesson = yield print(\"开始[%s]了,[%s]老师来讲课了!\" %(lesson,name)) def producer(name): c = consumer('A') c2 = consumer('B') c.__next__() c2.__next__() print(\"同学们开始上课 了!\") for i in range(10","date":"2020-06-25","objectID":"/GeneratorAndYield/:0:2","tags":["笔记","Generator","Yield"],"title":"生成器的运用","uri":"/GeneratorAndYield/"},{"categories":["笔记"],"content":"迭代器（迭代就是循环） 迭代器包含有next方法的实现，在正确的范围内返回期待的数据以及超出范围后能够抛出StopIteration的错误停止迭代。 我们已经知道，可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list,tuple,dict,set,str等 一类是generator，包括生成器和带yield的generator function 这些可以直接作用于for 循环的对象统称为可迭代对象：Iterable 可以使用isinstance()判断一个对象是否为可 Iterable 对象 \u003e\u003e\u003e from collections import Iterable \u003e\u003e\u003e isinstance([], Iterable) True \u003e\u003e\u003e isinstance({}, Iterable) True \u003e\u003e\u003e isinstance('abc', Iterable) True \u003e\u003e\u003e isinstance((x for x in range(10)), Iterable) True \u003e\u003e\u003e isinstance(100, Iterable) False 而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。 所以这里讲一下迭代器 一个实现了iter方法的对象是可迭代的，一个实现next方法并且是可迭代的对象是迭代器。 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 所以一个实现了iter方法和next方法的对象就是迭代器。 可以使用isinstance()判断一个对象是否是 Iterator 对象： \u003e\u003e\u003e from collections import Iterator \u003e\u003e\u003e isinstance((x for x in range(10)), Iterator) True \u003e\u003e\u003e isinstance([], Iterator) False \u003e\u003e\u003e isinstance({}, Iterator) False \u003e\u003e\u003e isinstance('abc', Iterator) False 生成器都是 Iterator 对象，但 list、dict、str 虽然是 Iterable（可迭代对象） ，却不是 Iterator（迭代器） 。 把list、dict、str 等 Iterable 变成 Iterator 可以使用 iter() 函数 ： \u003e\u003e\u003e isinstance(iter([]), Iterator) True \u003e\u003e\u003e isinstance(iter('abc'), Iterator) True 你可能会问，为什么 list、dict、str 等数据类型不是 Iterator ？ 这是因为Python的 Iterator 对象表示的是一个 数据流 ，Iterator对象可以被 next() 函数调用并不断返回下一个数据，直到没有数据时抛出 StopIteration 错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过 next() 函数实现按需计算下一个数据，所以 Iterator 的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator 甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 判断下列数据类型是可迭代对象or迭代器 s='hello' l=[1,2,3,4] t=(1,2,3) d={'a':1} set={1,2,3} f=open('a.txt') s='hello' #字符串是可迭代对象，但不是迭代器 l=[1,2,3,4] #列表是可迭代对象，但不是迭代器 t=(1,2,3) #元组是可迭代对象，但不是迭代器 d={'a':1} #字典是可迭代对象，但不是迭代器 set={1,2,3} #集合是可迭代对象，但不是迭代器 # ************************************* f=open('test.txt') #文件是可迭代对象，是迭代器 #如何判断是可迭代对象，只有__iter__方法，执行该方法得到的迭代器对象。 # 及可迭代对象通过__iter__转成迭代器对象 from collections import Iterator #迭代器 from collections import Iterable #可迭代对象 print(isinstance(s,Iterator)) #判断是不是迭代器 print(isinstance(s,Iterable)) #判断是不是可迭代对象 #把可迭代对象转换为迭代器 print(isinstance(iter(s),Iterator)) 注意：文件的判断 f = open('housing.csv') from collections import Iterator from collections import Iterable print(isinstance(f,Iterator)) print(isinstance(f,Iterable)) True True 　结论：文件是可迭代对象，也是迭代器 小结： 凡是可作用于 for 循环的对象都是 Iterable 类型； 凡是可作用于 next() 函数的对象都是 Iterator 类型，它们表示一个惰性计算的序列； 集合数据类型如 list、dict、str 等是 Iterable 但不是 Iterator ，不过可以通过 iter() 函数获得一个 Iterator 对象。 Python3的 for 循环本质上就是通过不断调用 next() 函数实现的，例如： for x in [1, 2, 3, 4, 5]: pass 实际上完全等价于 # 首先获得Iterator对象: it = iter([1, 2, 3, 4, 5]) # 循环: while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break ","date":"2020-06-25","objectID":"/GeneratorAndYield/:0:3","tags":["笔记","Generator","Yield"],"title":"生成器的运用","uri":"/GeneratorAndYield/"},{"categories":["笔记"],"content":"对yield的总结 （1）通常的for..in…循环中，in后面是一个数组，这个数组就是一个可迭代对象，类似的还有链表，字符串，文件。他可以是a = [1,2,3]，也可以是a = [x*x for x in range(3)]。 它的缺点也很明显，就是所有数据都在内存里面，如果有海量的数据，将会非常耗内存。 （2）生成器是可以迭代的，但是只可以读取它一次。因为用的时候才生成，比如a = (x*x for x in range(3))。!!!!注意这里是小括号而不是方括号。 （3）生成器（generator）能够迭代的关键是他有next()方法，工作原理就是通过重复调用next()方法，直到捕获一个异常。 （4）带有yield的函数不再是一个普通的函数，而是一个生成器generator，可用于迭代 （5）yield是一个类似return 的关键字，迭代一次遇到yield的时候就返回yield后面或者右面的值。而且下一次迭代的时候，从上一次迭代遇到的yield后面的代码开始执行 （6）yield就是return返回的一个值，并且记住这个返回的位置。下一次迭代就从这个位置开始。 （7）带有yield的函数不仅仅是只用于for循环，而且可用于某个函数的参数，只要这个函数的参数也允许迭代参数。 （8）send()和next()的区别就在于send可传递参数给yield表达式，这时候传递的参数就会作为yield表达式的值，而yield的参数是返回给调用者的值，也就是说send可以强行修改上一个yield表达式值。 （9）send()和next()都有返回值，他们的返回值是当前迭代遇到的yield的时候，yield后面表达式的值，其实就是当前迭代yield后面的参数。 （10）第一次调用时候必须先next（）或send（）,否则会报错，send后之所以为None是因为这时候没有上一个yield，所以也可以认为next（）等同于send(None) ","date":"2020-06-25","objectID":"/GeneratorAndYield/:0:4","tags":["笔记","Generator","Yield"],"title":"生成器的运用","uri":"/GeneratorAndYield/"},{"categories":["笔记"],"content":"补充：itertools库学习 库的官网地址：https://docs.python.org/2/library/itertools.html#itertools.permutations （此部分笔记参考博客：https://www.jb51.net/article/123094.htm） 迭代器（生成器）在Python中是一种很常用也很好用的数据结构，比起列表(list)来说，迭代器最大的优势就是延迟计算，按需使用，从而提高开发体验和运行效率，以至于在Python 3中map,filter等操作返回的不再是列表而是迭代器。 话虽这么说但大家平时用到的迭代器大概只有range了，而通过iter函数把列表对象转化为迭代器对象又有点多此一举，这时候我们今天的主角itertools就该上场了。 itertools中的额函数大多数是返回各种迭代器对象，其中很多函数的作用我们平时要写很多代码才能达到，而在运行效率上反而更低，毕竟人家是系统库。 1，itertools.accumulate 简单来说就是累加。 from itertools import accumulate x = accumulate(range(10)) print(list(x)) [0, 1, 3, 6, 10, 15, 21, 28, 36, 45] 2，itertools.permutations 产生指定数目元素的所有排列（顺序有关） from itertools import permutations x = permutations((1,2,3)) print(list(x)) [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)] python 生成器和迭代器有这篇就够了 - 战争热诚 - 博客园 ","date":"2020-06-25","objectID":"/GeneratorAndYield/:0:5","tags":["笔记","Generator","Yield"],"title":"生成器的运用","uri":"/GeneratorAndYield/"},{"categories":["笔记"],"content":"Python单例模式(Singleton)的N种实现 很多初学者喜欢用 全局变量 ，因为这比函数的参数传来传去更容易让人理解。确实在很多场景下用全局变量很方便。不过如果代码规模增大，并且有多个文件的时候，全局变量就会变得比较混乱。你可能不知道在哪个文件中定义了相同类型甚至重名的全局变量，也不知道这个变量在程序的某个地方被做了怎样的操作。 因此对于这种情况，有种更好的实现方式： 单例（Singleton） 单例是一种 设计模式 ，应用该模式的类只会生成一个实例。 单例模式保证了在程序的不同位置都 可以且仅可以取到同一个对象实例 ：如果实例不存在，会创建一个实例；如果已存在就会返回这个实例。因为单例是一个类，所以你也可以为其提供相应的操作方法，以便于对这个实例进行管理。 举个例子来说，比如你开发一款游戏软件，游戏中需要有“场景管理器”这样一种东西，用来管理游戏场景的切换、资源载入、网络连接等等任务。这个管理器需要有多种方法和属性，在代码中很多地方会被调用，且被调用的必须是同一个管理器，否则既容易产生冲突，也会浪费资源。这种情况下，单例模式就是一个很好的实现方法。 单例模式广泛应用于各种开发场景，对于开发者而言是必须掌握的知识点，同时在很多面试中，也是常见问题。本篇文章总结了目前主流的实现单例模式的方法供读者参考。 希望看过此文的同学，在以后被面到此问题时，能直接皮一下面试官，“我会 4 种单例模式实现，你想听哪一种？” 以下是实现方法索引： 使用函数装饰器实现单例 使用类装饰器实现单例 使用 new 关键字实现单例 使用 metaclass 实现单例 ","date":"2020-05-25","objectID":"/singleton/:0:0","tags":["笔记","Singleton"],"title":"单例模式实现","uri":"/singleton/"},{"categories":["笔记"],"content":"使用函数装饰器实现单例 以下是实现代码： def singleton(cls): _instance = {} def inner(): if cls not in _instance: _instance[cls] = cls() return _instance[cls] return inner @singleton class Cls(object): def __init__(self): pass cls1 = Cls() cls2 = Cls() print(id(cls1) == id(cls2)) 输出结果： True 在 Python 中，id 关键字可用来查看对象在内存中的存放位置，这里 cls1 和 cls2 的 id 值相同，说明他们指向了同一个对象。 关于装饰器的知识，有不明白的同学可以查看之前的文章 【编程课堂】装饰器浅析 或者使用搜索引擎再学习一遍。代码中比较巧妙的一点是: 使用不可变的 类地址 作为键，其实例作为值，每次创造实例时，首先查看该类是否存在实例，存在的话直接返回该实例即可，否则新建一个实例并存放在字典中。 ","date":"2020-05-25","objectID":"/singleton/:1:0","tags":["笔记","Singleton"],"title":"单例模式实现","uri":"/singleton/"},{"categories":["笔记"],"content":"使用类装饰器实现单例 代码： class Singleton(object): def __init__(self, cls): self._cls = cls self._instance = {} def __call__(self): if self._cls not in self._instance: self._instance[self._cls] = self._cls() return self._instance[self._cls] @Singleton class Cls2(object): def __init__(self): pass cls1 = Cls2() cls2 = Cls2() print(id(cls1) == id(cls2)) 同时，由于是面对对象的，这里还可以这么用 class Cls3(): pass Cls3 = Singleton(Cls3) cls3 = Cls3() cls4 = Cls3() print(id(cls3) == id(cls4)) 使用 类装饰器实现单例的原理和 函数装饰器 实现的原理相似，理解了上文，再理解这里应该不难。 ","date":"2020-05-25","objectID":"/singleton/:2:0","tags":["笔记","Singleton"],"title":"单例模式实现","uri":"/singleton/"},{"categories":["笔记"],"content":"New、Metaclass 关键字 在接着说另外两种方法之前，需要了解在 Python 中一个类和一个实例是通过哪些方法以怎样的顺序被创造的。 简单来说， 元类 ( metaclass ) 可以通过方法 metaclass 创造了 类(class) ，而 类(class) 通过方法 new 创造了 实例(instance) 。 在单例模式应用中，在创造类的过程中或者创造实例的过程中稍加控制达到最后产生的实例都是一个对象的目的。 本文主讲单例模式，所以对这个 topic 只会点到为止，有感兴趣的同学可以在网上搜索相关内容，几篇参考文章： ","date":"2020-05-25","objectID":"/singleton/:3:0","tags":["笔记","Singleton"],"title":"单例模式实现","uri":"/singleton/"},{"categories":["笔记"],"content":"使用 new 关键字实现单例模式 使用 new 方法在创造实例时进行干预，达到实现单例模式的目的。 class Single(object): _instance = None def __new__(cls, *args, **kw): if cls._instance is None: cls._instance = object.__new__(cls, *args, **kw) return cls._instance def __init__(self): pass single1 = Single() single2 = Single() print(id(single1) == id(single2)) 在理解到 new 的应用后，理解单例就不难了，这里使用了 来存放实例，如果 _instance 为 None，则新建实例，否则直接返回 _instance 存放的实例。 ","date":"2020-05-25","objectID":"/singleton/:4:0","tags":["笔记","Singleton"],"title":"单例模式实现","uri":"/singleton/"},{"categories":["笔记"],"content":"使用 metaclass 实现单例模式 同样，我们在类的创建时进行干预，从而达到实现单例的目的。 在实现单例之前，需要了解使用 type 创造类的方法，代码如下： def func(self): print(\"do sth\") Klass = type(\"Klass\", (), {\"func\": func}) c = Klass() c.func() 以上，我们使用 type 创造了一个类出来。这里的知识是 mataclass 实现单例的基础。 class Singleton(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs) return cls._instances[cls] class Cls4(metaclass=Singleton): pass cls1 = Cls4() cls2 = Cls4() print(id(cls1) == id(cls2)) 这里，我们将 metaclass 指向 Singleton 类，让 Singleton 中的 type 来创造新的 Cls4 实例。 ","date":"2020-05-25","objectID":"/singleton/:5:0","tags":["笔记","Singleton"],"title":"单例模式实现","uri":"/singleton/"},{"categories":["笔记"],"content":"小结 本文虽然是讲单例模式，但在实现单例模式的过程中，涉及到了蛮多高级 Python 语法，包括装饰器、元类、new、type 甚至 super 等等。对于新手同学可能难以理解，其实在工程项目中并不需要你掌握的面面俱到，掌握其中一种，剩下的作为了解即可。 by 周鑫鑫 关于更多的设计模式，给初学者推荐《 Head First 设计模式 》（Head First Design Patterns），此书浅显易懂，在 Head First 系列书籍里面也算是很好的一本。 ","date":"2020-05-25","objectID":"/singleton/:6:0","tags":["笔记","Singleton"],"title":"单例模式实现","uri":"/singleton/"},{"categories":["Algorithm"],"content":"Swap Nodes in Pairs ","date":"2019-05-29","objectID":"/SwapNodesinPairs/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-24-两两交换链表中的节点","uri":"/SwapNodesinPairs/"},{"categories":["Algorithm"],"content":"Leetcode 24.Swap Nodes in Pairs Given alinked list, swap every two adjacent nodes and return its head. You maynotmodify the values in the list’s nodes, only nodes itself may be changed. Example: Given 1-\u003e2-\u003e3-\u003e4, you should return the list as 2-\u003e1-\u003e4-\u003e3 #Author:kilien #Leetcode 24.Swap Nodes in Pairs #思路：定义哨兵节点，互换相邻节点及后继节点，详见图解 #time:O(n) space:O(n) # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def swapPairs(self, head: ListNode) -\u003e ListNode: pre, pre.next = self, head while pre.next and pre.next.next: a = pre.next b = a.next pre.next, b.next, a.next = b, a, b.next pre = a return self.next 初始状态： pre代表ListNode对象，指向自身None； pre后继节点为head，即第一个节点 后续定义两个指针变量：a,b a指向pre的后继节点 b指向a指针的后继节点，即value为2的节点 第一次循环： 将pre的后继指针指向b指针的节点，即value为2的节点 将b的后继指针指向a指针的节点，即value为1的节点 将a的后继指针指向b指针的后继指针所指节点，即value为3的节点 pre指针赋值为a指针所在位置 第一次循环： a指向pre的后继节点，即value为3的节点 b指向a指针的后继节点，即value为4的节点 将pre的后继指针指向b指针的节点，即value为4的节点 将b的后继指针指向a指针的节点，即value为3的节点 将a的后继指针指向b指针的后继指针所指节点，即尾节点None pre指针赋值为a指针所在位置 ","date":"2019-05-29","objectID":"/SwapNodesinPairs/:0:1","tags":["算法","Leetcode"],"title":"LeetCode-24-两两交换链表中的节点","uri":"/SwapNodesinPairs/"},{"categories":["Algorithm"],"content":"Linked List Cycle Leetcode 141.Linked List Cycle Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integerposwhich represents the position (0-indexed)in the linked list where tail connects to. Ifposis-1, then there is no cycle in the linked list. Example : Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node. 题意： 给定一个链表，判断链表中是否有环。 # Author:kilien # Leetcode 141.Linked List Cycle # 思路1：使用set记录链表元素，重复即有环 # time:O(n) space:O(n) class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" key = set() while head: if head in key: return True else: key.add(head) head = head.next return False # 思路2：使用快慢指针，当两者相遇则有环 # time：O(n) space:O(1) # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" fast = slow = head while fast and slow and fast.next: fast = fast.next.next slow = slow.next if fast is slow: return True return False 过程如图： ","date":"2019-05-27","objectID":"/LinkedListCycle/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-141-环形链表","uri":"/LinkedListCycle/"},{"categories":["Algorithm"],"content":"Sort List ","date":"2019-05-27","objectID":"/SortList/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-148-排序链表","uri":"/SortList/"},{"categories":["Algorithm"],"content":"LeetCode 148.Sort List Sort a linked list inO(nlogn) time using constant space complexity. Example 1: Input: 4-\u003e2-\u003e1-\u003e3 Output: 1-\u003e2-\u003e3-\u003e4 # Author：kilien # 思路：归并排序，分解链表，化整为零，再自底向上合并排序 # time：O（nlogn） space：O（nloagn） # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def merge(self, h1, h2): dummy = tail = ListNode(None) while h1 and h2: if h1.val \u003c h2.val: tail.next, tail, h1 = h1, h1, h1.next else: tail.next, tail, h2 = h2, h2, h2.next tail.next = h1 or h2 return dummy.next def sortList(self, head): if not head or not head.next: return head pre, slow, fast = None, head, head while fast and fast.next: pre, slow, fast = slow, slow.next, fast.next.next pre.next = None return self.merge(*map(self.sortList, (head, slow))) map 运用 map() 函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 \u003e\u003e\u003e def f(x): ... return x * x ... \u003e\u003e\u003e r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) \u003e\u003e\u003e list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81] map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。 ※ 的作用是将map对象作为实参传入merge函数。 具体流程可见图解： 初始状态： sortList\" sortList sortlist循环： sortList\" sortList sortList\" sortList 断链：pre.next = None sortList\" sortList 左子树拆分元素，合并排序 sortList\" sortList 右子树拆分：左1子树和右1子树 sortList\" sortList 左1子树不变，右1子树拆分元素，合并 sortList\" sortList 左1子树、右1子树合并 sortList\" sortList 左右子树合并 sortList\" sortList ","date":"2019-05-27","objectID":"/SortList/:0:1","tags":["算法","Leetcode"],"title":"LeetCode-148-排序链表","uri":"/SortList/"},{"categories":["Algorithm"],"content":"Reverse Linked List ","date":"2019-05-25","objectID":"/reverseLinkedList/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-206-反转链表","uri":"/reverseLinkedList/"},{"categories":["Algorithm"],"content":"Leetcode 206.Reverse Linked List 链表本质是理解“指针”的概念。指针在各种语言都有运用到，只是叫法不同，就像Java中是“引用”。实际上，意思都是存储对象的内存地址。 将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向这个变量，通过内存地址可以找到这个变量值。 大体如下图： array 下面通过一道简单的题目演示下链表移动。 Leetcode 206.Reverse Linked List Reverse a singly linked list. Example: Input: 1-\u003e2-\u003e3-\u003e4-\u003e5-\u003eNULL Output: 5-\u003e4-\u003e3-\u003e2-\u003e1-\u003eNULL #author:kilien #Leetcode 206.Reverse Linked List #思路：定义两个指针，指向前继节点和当前节点 #多元赋值，两两互换 #time:O(n) space:O(1) # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def reverseList(self, head: ListNode) -\u003e ListNode: cur, prev = head, None while cur: cur.next, prev, cur = prev, cur, cur.next return prev 初始状态： 第一次循环： 将当前节点的后继指针指向前继节点，头节点的前继为Null； 将当前节点的前继指针指向当前节点，即指向本身，value为1； 当前节点指针赋值为当前节点的后继节点，即value为2的节点 第二次循环： 将当前节点的后继指针指向前继节点，即value为1的节点； 将当前节点的前继指针指向当前节点，即value为2的节点； 当前节点指针赋值为当前节点的后继节点，即value为3的节点 第三次循环： 将当前节点的后继指针指向前继节点，即value为2的节点； 将当前节点的前继指针指向当前节点，即value为3的节点； 当前节点指针赋值为当前节点的后继节点，即value为None的节点 注：python中多位赋值类似构建一个元组存储临时变量,如下两段代码等价 #cur.next, prev, cur = prev, cur, cur.next tuples = (prev, cur, cur.next) cur.next = tuples[0] prev = tuples[1] cur = tuples[2] 链表中使用该方式需要注意赋值顺序，错位将导致链表断裂 ","date":"2019-05-25","objectID":"/reverseLinkedList/:0:1","tags":["算法","Leetcode"],"title":"LeetCode-206-反转链表","uri":"/reverseLinkedList/"},{"categories":["Algorithm"],"content":"LeetCode 322 零钱兑换 ","date":"2019-05-23","objectID":"/CoinChange/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-322-零钱兑换","uri":"/CoinChange/"},{"categories":["Algorithm"],"content":"题目： 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 **输入:**coins = [1, 2, 5], amount = 11 **输出:**3 **解释:** 11 = 5 + 5 + 1 题意解析： 有一堆不同面额的硬币，问最少取多少枚硬币，可以凑够想要的面值。 ","date":"2019-05-23","objectID":"/CoinChange/:0:1","tags":["算法","Leetcode"],"title":"LeetCode-322-零钱兑换","uri":"/CoinChange/"},{"categories":["Algorithm"],"content":"DFS解析： Coin Change - LeetCode 为了最终硬币数量最少，首先对硬币面值从大到小排序 因为面值大的越靠前，最后所需额度也会相应减小，硬币数量也会减少 构建DFS函数 确定边界，若不存在目标金额，则返回当前最小值 遍历硬币面值： 若存在当前硬币面值小于等于目标金额且目标金额小于边界条件（防止溢出），则drill down，进入下一层循环寻找剩余金额所需硬币 设置目标金额，遍历硬币面值，求解 def coinChange(self, coins, amount): coins.sort(reverse = True) coins_len, self.result = len(coins), float(“inf”) def dfs(index, target, count): if not target: self.res = min(self.res, count) for i in range(index, coins_len): if coins[i] \u003c= target \u003c coins[i] * (self.result-count): # if hope still exists dfs(i, target-coins[i], count+1) for i in range(coins_len): dfs(i, amount, 0) return self.result if self.result \u003c float(“inf”) else -1 ","date":"2019-05-23","objectID":"/CoinChange/:0:2","tags":["算法","Leetcode"],"title":"LeetCode-322-零钱兑换","uri":"/CoinChange/"},{"categories":["Algorithm"],"content":"剪枝 上面方式遍历过程中并不需要全部遍历全部结果，可以通过剪枝，去除多余的选项： 同上对硬币面值排序（从大到小） 构建countCoins函数： 设置金额上限及硬币上限，若当前金额大于目标金额则返回 求模，针对当前硬币和目标金额取模，若满足条件即表示当前的coin可以将目标金额填满，只需要计算coins即可 遍历目标金额，从大至小，依次递减1： 若存在目标金额与对应面值的硬币匹配的情况（求模），则将硬币记录下来 针对目标金额遍历求值即可 import math class Solution: def coinChange(self, coins: List[int], amount: int) -\u003e int: coins.sort(reverse = True) coins_len, result = len(coins), amount + 1 def countCoins(index, target, count): if count + math.ceil(target/coins[index]) \u003e= result: return if target % coins[index] == 0: result = count + target//coins[index] return if index == coins_len - 1: return for i in range(target//coins[index], -1, -1): countCoins(index+1, target - coins[index]*i, count+1) countCoins(0, amount, 0) return -1 if result \u003e amount else result ","date":"2019-05-23","objectID":"/CoinChange/:0:3","tags":["算法","Leetcode"],"title":"LeetCode-322-零钱兑换","uri":"/CoinChange/"},{"categories":["Algorithm"],"content":"BFS 解析 Coin Change - LeetCode 将问题转化为求X轴0点到坐标点amount的最短距离 （每次向前行进的合法距离为coin的面值） visited = [False]*(amount+1) 构建数组，存放后续遍历的节点 和DFS类似，先遍历对应硬币的面值 在这个过程中，计算当前硬币面值与已有硬币的和集，比较当前金额和目标金额的差异（相等则返回并记录硬币，超过目标金额则放弃，不处理） 若 当前金额不在已访问过的数组中，则将当前金额添加至已访问过的数组中 返回遍历后的结果 class Solution(object): def coinChange(self, coins, amount): if amount == 0: return 0 value1 = [0] value2 = [] nc = 0 visited = [False]*(amount+1) visited[0] = True while value1: nc += 1 for v in value1: for coin in coins: newval = v + coin if newval == amount: return nc elif newval \u003e amount: continue elif not visited[newval]: visited[newval] = True value2.append(newval) value1, value2 = value2, [] return -1 ","date":"2019-05-23","objectID":"/CoinChange/:0:4","tags":["算法","Leetcode"],"title":"LeetCode-322-零钱兑换","uri":"/CoinChange/"},{"categories":["Algorithm"],"content":"动态规划解析： Coin Change - LeetCode 首先声明一个大小为amount+1的数组dp，用dp[i]存储”对于金额amount最少用到的硬币数coins” 为什么大小是amount+1？比如amount是11块，dp要从0元开始存储到11块，所以数组的大小要amount+1 对于初始化数组dp的索引i=0的元素值为0，是因为0块要的硬币数为0，所以初始化为0 根据数组dp的定义，得到方程: dp[i] = min(dp[i-coin]+1) 注意：dp[i-coin]的coin是针对每一种硬币 返回值 dp[amount]返回dp数组的最后一个元素，dp[amount] == float(“inf”)返回dp数组最后的元素是否为inf(无穷大) 这里用一个例子解释[3, -1][True]返回的是索引为1的元素，[3, -1][False]返回索引为0的元素 所以dp[amount]不等于inf则返回dp[amount]，等于inf则返回-1，意味着任何一种硬币组合能组成总金额 time: O(amount*len(coins) 第一层循环遍历了amount次，第二层循环遍历了数组coins的每个元素 space: O(amount) 算法用一个大小为amount+1的数组来存储值 class Solution: def coinChange(self, coins: List[int], amount: int) -\u003e int: dp = [0] + [float(“inf”)] * amount for i in range(1, amount + 1): dp[i] = min([dp[i - c] if i - c \u003e= 0 else float(“inf”) for c in coins]) + 1 return [dp[amount], -1][dp[amount] == float(‘inf’)] 如上方式可以转换如下通俗的方式： class Solution: def coinChange(self, coins: List[int], amount: int) -\u003e int: n = len(coins) # dp[i]表示金额amount需要的最少coins数 dp = [float(\"inf\")] * (amount+1) dp[0] = 0 for i in range(amount+1): for j in range(n): if coins[j] \u003c= i: dp[i] = min(dp[i], dp[i-coins[j]]+1) return dp[amount] if dp[amount] \u003c= amount else -1 ","date":"2019-05-23","objectID":"/CoinChange/:0:5","tags":["算法","Leetcode"],"title":"LeetCode-322-零钱兑换","uri":"/CoinChange/"},{"categories":["Algorithm"],"content":"Implement Stack using Queues Leetcode 225. Implement Stack using Queues Implement the following operations of a stack using queues. push(x) — Push element x onto stack. pop() — Removes the element on top of the stack. top() — Get the top element. empty() — Return whether the stack is empty. Example: MyStack stack = new MyStack(); stack.push(1); stack.push(2); stack.top(); // returns 2 stack.pop(); // returns 2 stack.empty(); // returns false # @Author：Kilien # @lc app=leetcode id=225 lang=python3 # [225] Implement Stack using Queues # time:O(1) space:O(n) # 思路：双端队列，左进右出模拟栈 class MyStack: def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.stack = collections.deque([]) def push(self, x: int) -\u003e None: \"\"\" Push element x onto stack. \"\"\" self.stack.append(x) def pop(self) -\u003e int: \"\"\" Removes the element on top of the stack and returns that element. \"\"\" for i in range(len(self.stack) - 1): self.stack.append(self.stack.popleft()) return self.stack.popleft() def top(self) -\u003e int: \"\"\" Get the top element. \"\"\" return self.stack[-1] def empty(self) -\u003e bool: \"\"\" Returns whether the stack is empty. \"\"\" return len(self.stack) == 0 # Your MyStack object will be instantiated and called as such: # obj = MyStack() # obj.push(x) # param_2 = obj.pop() # param_3 = obj.top() # param_4 = obj.empty() Deque定义： Deque队列是由栈或者queue队列生成的（发音是 “deck”，”double-ended queue”的简称）。 Deque支持线程安全，内存高效添加(append)和弹出(pop)，从两端都可以，两个方向的大概开销都是 O(1) 复杂度。 Deque方法： append(x) 添加x到右端。 appendleft(x) 添加x到左端。 pop() 移去并且返回一个元素，deque最右侧的那一个。如果没有元素的话，就升起 IndexError 索引错误。 popleft() 移去并且返回一个元素，deque最左侧的那一个。如果没有元素的话，就升起 IndexError 索引错误。 \u003e\u003e\u003e from collections import deque \u003e\u003e\u003e d = deque('ghi') # make a new deque with three items \u003e\u003e\u003e for elem in d: # iterate over the deque's elements ... print(elem.upper()) G H I \u003e\u003e\u003e d.append('j') # add a new entry to the right side \u003e\u003e\u003e d.appendleft('f') # add a new entry to the left side \u003e\u003e\u003e d # show the representation of the deque deque(['f', 'g', 'h', 'i', 'j']) \u003e\u003e\u003e d.pop() # return and remove the rightmost item 'j' \u003e\u003e\u003e d.popleft() # return and remove the leftmost item 'f' \u003e\u003e\u003e list(d) # list the contents of the deque ['g', 'h', 'i'] \u003e\u003e\u003e d[0] # peek at leftmost item 'g' \u003e\u003e\u003e d[-1] # peek at rightmost item 'i' 具体可见官方文档： collections — 容器数据类型 — Python 3.7.3 文档 ","date":"2019-05-21","objectID":"/ImplementStackusingQueues/:0:0","tags":["算法","Leetcode"],"title":"ImplementStackusingQueues","uri":"/ImplementStackusingQueues/"},{"categories":["Algorithm"],"content":"Implement Queue using Stacks Leetcode 232.Implement Queue using Stacks Implement the following operations of a queue using stacks. push(x) — Push element x to the back of queue. pop() — Removes the element from in front of queue. peek() — Get the front element. empty() — Return whether the queue is empty. Example: MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // returns 1 queue.pop(); // returns 1 queue.empty(); // returns false # @Author：Kilien # @lc app=leetcode id=232 lang=python3 # [232] Implement Queue using Stacks # time:O(1) space:O(n) #思路：两个数组，模拟入栈出栈，实现队列；具体见图解 class MyQueue: def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.inStack, self.outStack = [], [] def push(self, x): \"\"\" :type x: int :rtype: nothing \"\"\" self.inStack.append(x) def pop(self): \"\"\" :rtype: nothing \"\"\" self.move() return self.outStack.pop() def peek(self): \"\"\" :rtype: int \"\"\" self.move() return self.outStack[-1] def empty(self): \"\"\" :rtype: bool \"\"\" return (not self.inStack) and (not self.outStack) def move(self): \"\"\" :rtype nothing \"\"\" if not self.outStack: while self.inStack: self.outStack.append(self.inStack.pop()) # Your MyQueue object will be instantiated and called as such: # obj = MyQueue() # obj.push(x) # param_2 = obj.pop() # param_3 = obj.peek() # param_4 = obj.empty() 初始建两个数组模拟栈： stack1 字符串”1，2，3“入栈： stack2 ”1，2，3“移动至outStack： stack3 ”4，5“入栈，”1，2，3“依次出栈，输出字符串”1，2，3“： stack4 ”4，5“移动至outStack： stack5 输出”4，5“： stack6 ","date":"2019-05-21","objectID":"/ImplementQueueusingStacks/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-232-用栈实现队列","uri":"/ImplementQueueusingStacks/"},{"categories":["Algorithm"],"content":"Valid Parentheses Leetcode 20.Valid Parentheses Given a string containing just the characters’(‘,’)’,’{‘,’}’,’[‘and’]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string isalso considered valid. Example1： Input: “()[]{}” Output: true Example2: Input: “([)]” Output: false # @Author：Kilien # @lc app=leetcode id=20 lang=python3 # # [20] Valid Parentheses # 思路：使用hashtable标记括号，拆分字符串 # 若字符串不在hashtable中，模拟入栈 # 若栈不为空，栈顶元素出栈，匹配括号则消除，不匹配则报错 class Solution: def isValid(self, s: str) -\u003e bool: stack = [] par_map = {')':'(',']':'[','}':'{'} for c in s: if c not in par_map: stack.append(c) elif not stack or par_map[c] != stack.pop(): return False return not stack ","date":"2019-05-20","objectID":"/ValidParentheses/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-20-有效括号","uri":"/ValidParentheses/"},{"categories":["Algorithm"],"content":"Valid Anagram Leetcode 242.Valid Anagram Given two strings s and t , write a function to determine if t is an anagram of s. Example： Input: s = “anagram”, t = “nagaram” Output: true Input: s = “rat”, t = “car” Output: false # @Author：Kilien # @lc app=leetcode id=242 lang=python3 # # [242] Valid Anagram # class Solution: # 思路：数组排序后比较差异 # def isAnagram(self, s: str, t: str) -\u003e bool: # return sorted(s) == sorted(t) # 思路：手动模拟hashtable，将字符串”a-z“的ASCII码作key， #计数求差异 def isAnagram(self, s: str, t: str) -\u003e bool: arr1, arr2 = [0]*26, [0]*26 for i in s: arr1[ord(i) - ord('a')] += 1 for i in t: arr2[ord(i) - ord('a')] += 1 return arr1 == arr2 # 思路：map计数，对比计数差异 \"\"\" def isAnagram(self, s: str, t: str) -\u003e bool: dict1, dict2 = {}, {} for item in s: dict1[item] = dict1.get(item,0) + 1 for item in t: dict2[item] = dict2.get(item,0) + 1 return dict1 == dict2 \"\"\" ","date":"2019-05-20","objectID":"/VaildAnagram/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-242-有效的字母异位词","uri":"/VaildAnagram/"},{"categories":["Algorithm"],"content":"Kth Largest Element in a Stream Leetcoed 703.Kth Largest Element in a Stream Design a class to findthekth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. YourKthLargestclass will have a constructor which accepts an integerkand an integer arraynums, which contains initial elements fromthe stream. For each call to the methodKthLargest.add, return the element representing the kth largest element in the stream. Example int k = 3; int[] arr = [4,5,8,2]; KthLargest kthLargest = new KthLargest(3, arr); kthLargest.add(3); // returns 4 kthLargest.add(5); // returns 5 kthLargest.add(10); // returns 5 kthLargest.add(9); // returns 8 kthLargest.add(4); // returns 8 题意： 设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。 # @Author:Kilien # @lc app=leetcode id=703 lang=python3 # # [703] Kth Largest Element in a Stream # 思路：将列表转化为小顶堆，保证第k个大的元素在堆顶， # 若堆中元素个数小于k，则后续元素入堆，重新排序，直至堆满足k个元素 # 若后续加入元素比堆顶大则剔除堆顶元素，该元素加入小顶堆，重新排序 # 若后续加入元素比堆顶小则忽略 class KthLargest: def __init__(self, k: int, nums: List[int]): self.pool = nums self.k = k heapq.heapify(self.pool) while len(self.pool) \u003e k: heapq.heappop(self.pool) def add(self, val: int) -\u003e int: if len(self.pool) \u003c self.k: heapq.heappush(self.pool, val) elif val \u003e self.pool[0]: heapq.heapreplace(self.pool, val) return self.pool[0] # Your KthLargest object will be instantiated and called as such: # obj = KthLargest(k, nums) # param_1 = obj.add(val) heapq定义： 这个模块提供了堆队列算法的实现，也称为优先队列算法。 堆是一个二叉树，它的每个父节点的值都只会小于或大于所有孩子节点（的值）。它使用了数组来实现：从零开始计数，对于所有的 k ，都有heap[k] \u003c= heap[2k+1]和 heap[k] \u003c= heap[2k+2] 。 为了便于比较，不存在的元素被认为是无限大。堆最有趣的特性在于最小的元素总是在根结点：heap[0] 。 heaoq方法： heapq.heappush(heap, item) 将 item 的值加入 heap 中，保持堆的不变性。 heapq.heappop(heap) 弹出并返回 heap 的最小的元素，保持堆的不变性。如果堆为空，抛出 IndexError 。使用 heap[0] ，可以只访问最小的元素而不弹出它。 heapq.heappushpop(heap, item) 将 item 放入堆中，然后弹出并返回 heap 的最小元素。该组合操作比先调用 heappush() 再调用 heappop() 运行起来更有效率。 heapq.heapify(x) 将list x 转换成堆，原地，线性时间内。 详见官方文档： heapq — 堆队列算法 — Python 3.7.3 文档 ","date":"2019-05-19","objectID":"/KthStream/:0:0","tags":["算法","Leetcode"],"title":"LeetCode-703-数据流中的第 K 大元素","uri":"/KthStream/"},{"categories":["Algorithm"],"content":"LinkedList 链表的结构还是比较直观的，就像一条锁链，换换相扣。程序中它通过 指针将零散的内存块地址串联起来，无须顺序存储；而指针即指向存储对象的内存地址的变量。 将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向这个变量，通过内存地址可以找到这个变量值。 ","date":"2019-05-15","objectID":"/LinkedList/:0:0","tags":["算法"],"title":"LinkedList","uri":"/LinkedList/"},{"categories":["Algorithm"],"content":"链表数据结构 链表节点的结构： class ListNode: def __init__(self, x): self.val = x self.next = None linkedlist 如图所示，一个节点记录两部分内容： 数据域：节点的值，即 23 指针域：对应下个节点的内存地址值，即后继指针 next linkedlist 一般而言，第一个节点称作头节点，最后一个节点称作尾节点； 头节点一般作为链表的起始标记，便于便利链表；尾节点的指针则是指向None,即空地址。 ","date":"2019-05-15","objectID":"/LinkedList/:0:1","tags":["算法"],"title":"LinkedList","uri":"/LinkedList/"},{"categories":["Algorithm"],"content":"插入操作与指针丢失 由于链表的特性，插入删除操作只需要找到对应节点直接插入即可，所以时间复杂度是O（1）；下面通过例子演示下插入操作： 如图，将在 23节点和12节点间插入14节点： [image:708D7997-7D7E-4CD5-9E2D-4B942D4718A0-313-0001C97522ACFEA9/linkedlist2png.png] x.next = cur.next; // 将 x 的结点的 next 指针指向下一结点； cur.next = x; // 将 cur 的 next 指针指向 x 结点； 实现插入、删除的过程需要注意赋值操作顺序。 我在做题的过程中，经常会想当然的先将当前节点和下一节点的连结断开，即cur.next指针指向x节点。再去关联x的后继节点。 若是像上面这样，将两句调换顺序则会指针丢失，导致断链。 ","date":"2019-05-15","objectID":"/LinkedList/:0:2","tags":["算法"],"title":"LinkedList","uri":"/LinkedList/"},{"categories":["Algorithm"],"content":"哨兵节点 上面提到头节点和尾节点有着不同的特性，因而在实现插入、删除操作的时候，需要格外进行处理，这样代码实现会繁琐许多。 这里将引入哨兵节点的概念，哨兵就像标识牌一样作为一个标志，如链表结构图中的head节点，该节点不直接参与业务，只是标记位置。 head节点一般不存储数据；当其作为一个标志位存在时，插入第一个节点和删除最后一个节点都可以复用同一代码逻辑。 ","date":"2019-05-15","objectID":"/LinkedList/:0:3","tags":["算法"],"title":"LinkedList","uri":"/LinkedList/"},{"categories":["Algorithm"],"content":"边界条件 代码实现过程中，总会碰到一些边界或是极端情况，这时候没有写边界条件，迎来的往往是雪崩。 之前做题就遇到过，由于未判定尾节点的情况，导致断链。做题的时候，最好列一下check list： 链表为空 只包含头节点或尾节点 处理尾节点逻辑 赋值顺序 链表合并 上面只是笼统的举例，具体还是得看题，想想极端情况下代码是否能运行；最好画下图解，方便记忆。 ","date":"2019-05-15","objectID":"/LinkedList/:0:4","tags":["算法"],"title":"LinkedList","uri":"/LinkedList/"},{"categories":["Life"],"content":"闲适少绪 午后闲暇无事，寻一处阴凉地界，伏坐树下。举目四眺，偶摘一叶，方觉“一叶障目”并非妄言。 抬手观之，其叶碧华如玉，温润柔滑，明晰净透。根分三茎，主茎自下贯穿，次从以环合主茎，丝络连绵不绝，晰之若晶莹剔透。上倚玄青天幕，娉婷立于云巅，仿佛兮若婀娜神女，玉貌韶年，冰肌雪脂，环腰如素，霞云似裙带飘舞飞扬，仿若流逸倩女欲乘风而去。横置远望，形若骄阳升朝霞；迫而察之，颜如芙蕖出渌波。 悠悠间，忽现昨日烟云变幻。昨时缥缈云雾，形状诡谲，无不巧然形物，惟妙惟肖。云幕之中，或虎踞龙盘，或厉鬼英魂，或楼阁亭台，间又以流云铺漫青岩，黑石中缀如鸟，若行于其间俯仰皆得，恍恍然如历异世焉。 清风入耳，往昔如烟过。听闻水声，却是鱼儿浮游远逝。翛然而来，悠忽而去，好不自在。凭拦坐望，清幽寒池，山风徐徐，日映华水，粼粼波光，好似月光碎片。忽念往日垂钓，得锦鲤，开合唇间，鬓须长扬，犹若龙象。莫非鱼龙之说有据？哈，何故多虑。捻叶作舟，借风东去，逐碧波，卧龙侧，悉凭天意。 Tips 回首晴天，双燕排云上。 日晕澄潭，未知虬龙卧。 随意遐想，却昏昏睡去。 日暮时分，丹霞万顷，上下天光，气接云空，如梦似幻。所处虽非峰峦叠翠，横巘联岚，却也绿树深山，飞瀑流泉，别是一番风味。待到暮色渐深，蝙蝠伏匿，寻夜食。常言蝠蛇其心，又闻嗜血性诡，多变常式，人多惧怕。然善观之，其行不由足，飞不假翼，夜捕蚊虫食之。池间多蚊虫，甚合我意，常观其行。 夜半钟声到客船，此时无声胜有声。昨夜月明如灯火皎辉，隐了星迹，直言月明星稀，浮华万千，乡里安得旧颜？今夜另寻他处，上得楼台，不见月华，却是偶得繁星一片。瑰丽之景暂按不表，踱至明处，方见阁楼檐角，旁悬玉盘，岂非明月？善。道是“不识庐山真面目，只缘身在此山中”。 月上中天，贪看数眼，依日前所想，聊作此篇。闲情逸致也。 ","date":"2015-08-01","objectID":"/confus/:0:0","tags":["生活","随笔"],"title":"闲适少绪","uri":"/confus/"}]